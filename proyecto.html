<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análisis Avanzado de Modelos - HTML/JavaScript</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/mathjs@12.4.2/lib/browser/math.js"></script>
    <script src="https://visjs.github.io/vis-network/standalone/umd/vis-network.min.js"></script> <style>
        .matrix-input-container {
            display: grid;
            gap: 5px;
            margin-top: 15px;
        }
        .matrix-input-container input {
            text-align: center;
        }
        #matrix-setup-container, #hmm-inputs, #bayesian-inputs, #cm-visualization {
            display: none;
        }
        #network-visualization {
            width: 100%;
            height: 300px;
            border: 1px solid #ccc;
            margin-top: 20px;
        }
        #markov-graph {
             width: 100%; 
             height: 250px; 
             border: 1px dashed #ddd; 
             margin-top: 15px;
        }
    </style>
</head>
<body>

    <div class="container my-5">
        <h1 class="mb-4 text-center text-primary">⚙️ Calculadora de Inferencia y Modelos (RB, CM, HMM)</h1>
        <p class="text-center text-muted">Solución 100% portable. Simplemente abra el archivo.</p>
        
        <div class="card shadow-lg">
            <div class="card-body">
                
                <div class="mb-4">
                    <label for="model_select" class="form-label h5">1. Seleccionar Área de Análisis:</label>
                    <select id="model_select" class="form-select form-select-lg" onchange="toggleInputs()">
                        <option value="" selected disabled>--- Selecciona un Modelo ---</option>
                        <option value="markov">Cadenas de Markov (CM)</option>
                        <option value="hmm">Modelos Ocultos de Markov (HMM)</option>
                        <option value="bayesian">Redes Bayesianas (RB)</option>
                    </select>
                </div>

                <div id="bayesian-inputs">
                    <hr>
                    <h4 class="mt-4 text-secondary">Red Bayesiana (RB): Inferencia Exacta (Ejemplo Fijo: "Lluvia, Aspersor, Pasto")</h4>
                    
                    <div id="network-visualization"></div>
                    
                    <h5 class="mt-3">Consultas de Probabilidad (Algoritmo de Enumeración)</h5>
                    <small class="text-muted">P(Query | Evidence). Implementación para estructura fija.</small>
                    
                    <div class="row g-3 mt-2">
                        <div class="col-md-4">
                            <label for="rb_query" class="form-label">Query (Q):</label>
                            <select id="rb_query" class="form-select"></select>
                        </div>
                        <div class="col-md-4">
                            <label for="rb_evidence_node" class="form-label">Evidencia (E):</label>
                            <select id="rb_evidence_node" class="form-select"></select>
                        </div>
                         <div class="col-md-4">
                            <label for="rb_evidence_value" class="form-label">Valor de Evidencia:</label>
                            <select id="rb_evidence_value" class="form-select">
                                <option value="true">Verdadero</option>
                                <option value="false">Falso</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="matrix-setup-container">
                    <hr>
                    <h4 class="mt-4 text-secondary">Cadenas de Markov (CM) y HMM</h4>
                    <div class="row g-3 align-items-end mb-4">
                        <div class="col-md-6">
                            <label for="matrix_size" class="form-label h5">2. Tamaño de Estados (N x N):</label>
                            <input type="number" id="matrix_size" class="form-control" value="3" min="2" max="5" oninput="generateMatrixInputs(this.value)">
                        </div>
                        <div class="col-md-6">
                            <button class="btn btn-warning w-100" onclick="generateMatrixInputs(document.getElementById('matrix_size').value)">Generar Campos de Matriz</button>
                        </div>
                    </div>
                    
                    <h5 class="mt-3">Matriz de Transición (A)</h5>
                    <div id="matrix_a_inputs" class="matrix-input-container"></div>
                    
                    <div id="cm-visualization">
                        <h5 class="mt-3">Visualización del Grafo de Estados (CM)</h5>
                        <div id="markov-graph"></div>
                    </div>

                    <div id="hmm-inputs">
                        <hr>
                        <h5 class="mt-4">Inputs HMM (Forward, Viterbi, Forward-Backward)</h5>
                        
                        <div class="mb-3">
                            <label for="observation_size" class="form-label">Número de Símbolos de Observación (M):</label>
                            <input type="number" id="observation_size" class="form-control" value="3" min="1" max="5" oninput="generateEmissionMatrixInputs()">
                        </div>
                        
                        <h5 class="mt-3">Matriz de Emisión (B)</h5>
                        <div id="matrix_b_inputs" class="matrix-input-container"></div>

                        <h5 class="mt-3">Probabilidades Iniciales ($\pi$)</h5>
                        <div id="vector_pi_inputs" class="matrix-input-container"></div>
                        
                        <h5 class="mt-3">Secuencia de Observaciones (Síntomas)</h5>
                        <input type="text" id="observations" class="form-control" placeholder="Ingrese síntomas separados por coma (ej: Normal, Frio, Mareado)" value="Normal,Frio,Mareado">
                    </div>
                </div>

                <hr>
                <button id="calculate_btn" class="btn btn-success btn-lg w-100 mt-4" onclick="performCalculation()">
                    3. Calcular y Graficar
                </button>
            </div>
        </div>

        <div class="card mt-4 shadow-sm">
            <div class="card-header bg-dark text-white h4">
                Resultados
            </div>
            <div class="card-body">
                <pre id="output_result" class="p-3 bg-light border rounded">Seleccione un modelo y presione 'Calcular y Graficar'...</pre>
                <div id="hmm-visualization" class="mt-3"></div>
            </div>
        </div>

    </div>

    <script>
        const m = math;
        
        // --- Constantes para HMM y RB ---
        const SYMPTOM_LABELS = ['Normal', 'Frio', 'Mareado', 'Tos', 'Fiebre']; 
        const SYMPTOM_MAP = SYMPTOM_LABELS.reduce((map, label, index) => {
            map[label.toLowerCase()] = index;
            return map;
        }, {});
        
        // Estructura fija de la Red Bayesiana (RB)
        const BAYESIAN_NETWORK = {
            nodes: ['Rain', 'Sprinkler', 'WetGrass'],
            cpt: {
                'Rain': { '': [0.2, 0.8] }, 
                'Sprinkler': {
                    'Rain=true': [0.01, 0.99], 
                    'Rain=false': [0.4, 0.6] 
                },
                'WetGrass': {
                    'Rain=true,Sprinkler=true': [0.99, 0.01],
                    'Rain=true,Sprinkler=false': [0.8, 0.2],
                    'Rain=false,Sprinkler=true': [0.9, 0.1],
                    'Rain=false,Sprinkler=false': [0.0, 1.0]
                }
            },
            structure: {
                'Rain': [],
                'Sprinkler': ['Rain'],
                'WetGrass': ['Rain', 'Sprinkler']
            }
        };

        // --- FUNCIONES DE LECTURA DE DATOS (Soluciona el error '.size' de HMM) ---
        
        function readMatrixFromHtml(prefix, N_rows, N_cols) {
            const matrix = [];
            for (let i = 0; i < N_rows; i++) {
                const row = [];
                for (let j = 0; j < N_cols; j++) {
                    const value = document.getElementById(`${prefix}_${i}_${j}`) ? document.getElementById(`${prefix}_${i}_${j}`).value : 0.0;
                    row.push(parseFloat(value) || 0.0); 
                }
                matrix.push(row);
            }
            // Importante: Retorna la matriz como objeto de math.js
            return m.matrix(matrix); 
        }

        function readVectorFromHtml(prefix, N) {
            const vector = [];
            for (let i = 0; i < N; i++) {
                const value = document.getElementById(`${prefix}_${i}`) ? document.getElementById(`${prefix}_${i}`).value : 0.0;
                vector.push(parseFloat(value) || 0.0);
            }
            return m.matrix(vector);
        }
        
        function validateStochasticMatrix(matrix, atol = 0.001) {
            const rows = matrix.toArray();
            for (let i = 0; i < rows.length; i++) {
                const sum = rows[i].reduce((a, b) => a + b, 0); 
                if (Math.abs(sum - 1.0) > atol) {
                    return `La suma de la fila ${i} es ${sum.toFixed(4)}, debería ser 1.0.`;
                }
            }
            return null;
        }

        // --- Funciones de Interfaz y Visualización ---

        function generateMatrixInputs(N) {
             N = parseInt(N);
            if (isNaN(N) || N < 2) return;
            const A_container = document.getElementById('matrix_a_inputs');
            A_container.innerHTML = '';
            A_container.style.gridTemplateColumns = `repeat(${N}, 1fr)`;
            
            const diagonal_val = 0.7;
            const off_diagonal_val = ((1 - diagonal_val) / (N - 1)).toFixed(3);

            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    const default_val = (N > 1) ? ((i === j) ? diagonal_val : off_diagonal_val) : 1.0;
                    A_container.innerHTML += `<input type="number" step="0.01" min="0" max="1" id="A_${i}_${j}" class="form-control form-control-sm" placeholder="A[${i}][${j}]" value="${default_val}">`;
                }
            }
            if (document.getElementById('model_select').value === 'hmm') {
                 generateEmissionMatrixInputs();
            }
            drawMarkovGraph();
        }

        function generateEmissionMatrixInputs() {
            const N = parseInt(document.getElementById('matrix_size').value);
            const M = parseInt(document.getElementById('observation_size').value);
            if (isNaN(N) || N < 1 || isNaN(M) || M < 1) return;
            
            const B_container = document.getElementById('matrix_b_inputs');
            B_container.innerHTML = '';
            B_container.style.gridTemplateColumns = `repeat(${M}, 1fr)`;
            const emission_default_val = (1/M).toFixed(3);

            for (let i = 0; i < N; i++) {
                for (let j = 0; j < M; j++) {
                    B_container.innerHTML += `<input type="number" step="0.01" min="0" max="1" id="B_${i}_${j}" class="form-control form-control-sm" placeholder="B[${i}][${j}] (${SYMPTOM_LABELS[j] || 'Obs' + j})" value="${emission_default_val}">`;
                }
            }
            
            const Pi_container = document.getElementById('vector_pi_inputs');
            Pi_container.innerHTML = '';
            Pi_container.style.gridTemplateColumns = `repeat(${N}, 1fr)`;
            const pi_default_val = (1/N).toFixed(3);
            for (let i = 0; i < N; i++) {
                Pi_container.innerHTML += `<input type="number" step="0.01" min="0" max="1" id="Pi_${i}" class="form-control form-control-sm" placeholder="π[${i}]" value="${pi_default_val}">`;
            }
        }
        
        function toggleInputs() {
            const model = document.getElementById('model_select').value;
            const setupContainer = document.getElementById('matrix-setup-container');
            const hmmInputs = document.getElementById('hmm-inputs');
            const bayesianInputs = document.getElementById('bayesian-inputs');
            const cmVis = document.getElementById('cm-visualization');

            setupContainer.style.display = 'none';
            hmmInputs.style.display = 'none';
            bayesianInputs.style.display = 'none';
            cmVis.style.display = 'none';

            if (model === 'markov') {
                setupContainer.style.display = 'block';
                cmVis.style.display = 'block';
                generateMatrixInputs(document.getElementById('matrix_size').value);
            } else if (model === 'hmm') {
                setupContainer.style.display = 'block';
                hmmInputs.style.display = 'block';
                generateMatrixInputs(document.getElementById('matrix_size').value);
            } else if (model === 'bayesian') {
                bayesianInputs.style.display = 'block';
                setupBayesianNetwork();
            }
        }
        
        function drawMarkovGraph() {
            const container = document.getElementById('markov-graph');
            const N = parseInt(document.getElementById('matrix_size').value);
            if (isNaN(N) || N < 2) {
                 container.innerHTML = '<p class="text-center text-muted">Ajuste el tamaño para visualizar el grafo de estados.</p>';
                 return;
            }

            const nodes = [];
            for(let i = 0; i < N; i++) {
                nodes.push({id: i, label: `Estado ${i}`, color: { background: '#2b7ce3', border: '#1e5f98' }, font: { color: 'white' }});
            }

            const edges = [];
            const A = readMatrixFromHtml('A', N, N).toArray(); 

            for(let i = 0; i < N; i++) {
                for(let j = 0; j < N; j++) {
                    const prob = A[i][j];
                    if (prob > 0.001) { 
                        edges.push({
                            from: i, 
                            to: j, 
                            label: prob.toFixed(3), 
                            arrows: 'to',
                            // Usar 'circular' o 'curvedCW' para auto-bucles y aristas dobles
                            smooth: {type: i === j ? 'curvedCW' : 'dynamic'}, 
                            dashes: prob < 0.2 ? true : false,
                            width: prob * 5 // El grosor de la línea refleja la probabilidad
                        });
                    }
                }
            }

            const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };
            const options = {
                layout: { hierarchical: false },
                edges: { font: { align: 'middle' }, color: { color: '#666', highlight: '#FF0000' } },
                physics: { enabled: true, solver: 'barnesHut' }
            };
            new vis.Network(container, data, options);
        }

        function setupBayesianNetwork() {
            const nodes = BAYESIAN_NETWORK.nodes.map(node => ({
                id: node,
                label: node,
                shape: 'box',
                color: '#ffc107'
            }));

            const edges = [];
            BAYESIAN_NETWORK.nodes.forEach(node => {
                BAYESIAN_NETWORK.structure[node].forEach(parent => {
                    edges.push({ from: parent, to: node, arrows: 'to', color: '#dc3545' });
                });
            });

            const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };
            const container = document.getElementById('network-visualization');
            const options = {
                layout: { hierarchical: false },
                edges: { smooth: true },
                physics: { enabled: true, solver: 'barnesHut' }
            };
            new vis.Network(container, data, options);
            
            const querySelect = document.getElementById('rb_query');
            const evidenceNodeSelect = document.getElementById('rb_evidence_node');
            
            querySelect.innerHTML = '';
            evidenceNodeSelect.innerHTML = '';
            BAYESIAN_NETWORK.nodes.forEach(node => {
                querySelect.innerHTML += `<option value="${node}">${node}</option>`;
                evidenceNodeSelect.innerHTML += `<option value="${node}">${node}</option>`;
            });
            // Remover el nodo de consulta del nodo de evidencia para evitar P(A|A)
            if(querySelect.value) {
                const optionToRemove = evidenceNodeSelect.querySelector(`option[value="${querySelect.value}"]`);
                if(optionToRemove) evidenceNodeSelect.removeChild(optionToRemove);
            }
        }
        
        // --- LÓGICA DE CADENAS DE MARKOV (Soluciona el error 'calculateMarkov not defined') ---
        
        function calculateMarkov(A, N) {
            const validationError = validateStochasticMatrix(A);
            if (validationError) {
                return `ERROR de Validación (Matriz A): ${validationError}`;
            }
            
            try {
                // Resolver (A^T - I) * pi = 0, sujeto a sum(pi) = 1
                const I = m.identity(N);
                const At = m.transpose(A);
                const M = m.subtract(At, I);
                
                // Reemplazar la última fila por [1, 1, ..., 1] (condición de suma)
                const M_array = M.toArray();
                M_array[N - 1] = Array(N).fill(1.0);
                const M_solved = m.matrix(M_array);
                
                // Vector b = [0, 0, ..., 1]
                const b = Array(N).fill(0.0);
                b[N - 1] = 1.0;

                // Resolver M * pi = b
                const pi_stationary_matrix = m.lusolve(M_solved, b);
                const pi_stationary = m.squeeze(pi_stationary_matrix).toArray();

                const output = `--- CÁLCULO DE CADENA DE MARKOV ---\n`
                    + `Matriz de Transición (A):\n${m.format(A, {precision: 4})}\n\n`
                    + `Distribución Estacionaria (π):\n[${pi_stationary.map(p => p.toFixed(4)).join(', ')}]\n`
                    + `Esta distribución representa la probabilidad a largo plazo de estar en cada estado.`;
                return output;

            } catch (e) {
                return `ERROR de Cálculo: No se pudo encontrar la distribución estacionaria. La matriz podría ser periódica o no regular. Detalle: ${e.message}`;
            }
        }

        // --- LÓGICA DE REDES BAYESIANAS (Enumeración) ---

        function calculateBayesianEnumeration() {
            const queryNode = document.getElementById('rb_query').value;
            const evidenceNode = document.getElementById('rb_evidence_node').value;
            const evidenceValue = document.getElementById('rb_evidence_value').value === 'true';

            const hiddenNodes = BAYESIAN_NETWORK.nodes.filter(n => n !== queryNode && n !== evidenceNode);
            const allNodes = BAYESIAN_NETWORK.nodes;
            
            let probTrue = 0;
            let probFalse = 0;

            function enumerate_all(vars, assignment = {}) {
                if (vars.length === 0) {
                    let p_joint = 1.0;
                    allNodes.forEach(node => {
                        const parents = BAYESIAN_NETWORK.structure[node];
                        let key = parents.map(p => `${p}=${assignment[p]}`).join(',');
                        
                        const nodeCPT = BAYESIAN_NETWORK.cpt[node];
                        const probIndex = assignment[node] ? 0 : 1;
                        
                        if (parents.length === 0) key = '';

                        const p = nodeCPT[key][probIndex];
                        p_joint *= p;
                    });

                    if (assignment[queryNode] === true) {
                        probTrue += p_joint;
                    } else {
                        probFalse += p_joint;
                    }
                    return;
                }

                const [X, ...rest] = vars;
                
                enumerate_all(rest, { ...assignment, [X]: true });
                enumerate_all(rest, { ...assignment, [X]: false });
            }
            
            // Asignar evidencia y consulta
            const initialAssignmentTrue = { [evidenceNode]: evidenceValue, [queryNode]: true };
            enumerate_all(hiddenNodes, initialAssignmentTrue);

            const initialAssignmentFalse = { [evidenceNode]: evidenceValue, [queryNode]: false };
            enumerate_all(hiddenNodes, initialAssignmentFalse);
            
            const totalProb = probTrue + probFalse;
            
            if (isNaN(totalProb) || totalProb === 0) {
                 return "ERROR DE CÁLCULO: La probabilidad de evidencia P(E) es cero. Intente otra consulta.";
            }

            const P_Q_true_given_E = probTrue / totalProb;
            const P_Q_false_given_E = probFalse / totalProb;
            
            const output = `--- RED BAYESIANA (ENUMERACIÓN) ---\n`
                + `Consulta: P(${queryNode} | ${evidenceNode}=${evidenceValue})\n`
                + `P(${queryNode}=Verdadero | E) = ${P_Q_true_given_E.toFixed(6)}\n`
                + `P(${queryNode}=Falso | E)    = ${P_Q_false_given_E.toFixed(6)}\n\n`
                + `Nota: Implementación de Enumeración para Red Fija.`;
            
            return output;
        }

        // --- LÓGICA HMM (Forward, Viterbi, Backward) ---

        function calculateForward(A, B, Pi, Observations) {
            const N = A.size()[0]; 
            const T = Observations.length;
            const alpha = m.zeros(T, N).toArray();
            
            const A_arr = A.toArray();
            const B_arr = B.toArray();
            const Pi_arr = Pi.toArray();
            
            for (let i = 0; i < N; i++) {
                alpha[0][i] = Pi_arr[i] * B_arr[i][Observations[0]];
            }

            for (let t = 1; t < T; t++) {
                const o_t = Observations[t];
                for (let j = 0; j < N; j++) {
                    let sum = 0;
                    for (let i = 0; i < N; i++) {
                        sum += alpha[t-1][i] * A_arr[i][j];
                    }
                    alpha[t][j] = sum * B_arr[j][o_t];
                }
            }

            const P_O = alpha[T-1].reduce((a, b) => a + b, 0);
            return { alpha: alpha, P_O: P_O };
        }
        
        function calculateBackward(A, B, Observations) {
            const N = A.size()[0]; 
            const T = Observations.length;
            const beta = m.zeros(T, N).toArray();

            const A_arr = A.toArray();
            const B_arr = B.toArray();

            for (let i = 0; i < N; i++) {
                beta[T-1][i] = 1.0;
            }

            for (let t = T - 2; t >= 0; t--) {
                const o_t_plus_1 = Observations[t+1];
                for (let i = 0; i < N; i++) {
                    let sum = 0;
                    for (let j = 0; j < N; j++) {
                        sum += A_arr[i][j] * B_arr[j][o_t_plus_1] * beta[t+1][j];
                    }
                    beta[t][i] = sum;
                }
            }
            return beta;
        }

        function calculateForwardBackward(alpha, beta, P_O) {
            const T = alpha.length;
            const N = alpha[0].length;
            const gamma = m.zeros(T, N).toArray(); 
            
            for (let t = 0; t < T; t++) {
                let sum_alpha_beta = 0;
                for (let i = 0; i < N; i++) {
                    sum_alpha_beta += alpha[t][i] * beta[t][i];
                }
                
                for (let i = 0; i < N; i++) {
                    // Evitar división por cero si P(O) es extremadamente pequeña
                    gamma[t][i] = (sum_alpha_beta !== 0) ? (alpha[t][i] * beta[t][i]) / sum_alpha_beta : 0;
                }
            }
            return gamma;
        }

        function calculateViterbi(A, B, Pi, Observations) {
            // Se mantiene la lógica de Viterbi con logaritmos para evitar underflow
            const N = A.size()[0]; 
            const T = Observations.length;
            const A_arr = A.toArray();
            const B_arr = B.toArray();
            const Pi_arr = Pi.toArray();
            const delta_arr = m.zeros(T, N).toArray();
            const psi_arr = m.zeros(T, N).toArray();

            for (let i = 0; i < N; i++) {
                const log_pi = Pi_arr[i] > 0 ? Math.log(Pi_arr[i]) : -Infinity;
                const log_b = B_arr[i][Observations[0]] > 0 ? Math.log(B_arr[i][Observations[0]]) : -Infinity;
                delta_arr[0][i] = log_pi + log_b;
            }

            for (let t = 1; t < T; t++) {
                const o_t = Observations[t];
                for (let j = 0; j < N; j++) {
                    let log_max_prob = -Infinity;
                    let max_state = 0;
                    for (let i = 0; i < N; i++) {
                        const log_a = A_arr[i][j] > 0 ? Math.log(A_arr[i][j]) : -Infinity;
                        const prob = delta_arr[t-1][i] + log_a;
                        if (prob > log_max_prob) {
                            log_max_prob = prob;
                            max_state = i;
                        }
                    }
                    const log_b = B_arr[j][o_t] > 0 ? Math.log(B_arr[j][o_t]) : -Infinity;
                    delta_arr[t][j] = log_max_prob + log_b;
                    psi_arr[t][j] = max_state;
                }
            }
            
            let log_P_star = -Infinity;
            let Q_T_minus_1 = 0;
            for (let i = 0; i < N; i++) {
                if (delta_arr[T-1][i] > log_P_star) {
                    log_P_star = delta_arr[T-1][i];
                    Q_T_minus_1 = i;
                }
            }
            
            const Q_star = new Array(T);
            Q_star[T-1] = Q_T_minus_1;

            for (let t = T - 2; t >= 0; t--) {
                Q_star[t] = psi_arr[t + 1][Q_star[t + 1]];
            }

            return `Secuencia Oculta Más Probable (Viterbi - Q*):\n[${Q_star.join(', ')}] (Prob. Logarítmica: ${log_P_star.toFixed(4)})`;
        }


        // --- FUNCIÓN PRINCIPAL DE CÁLCULO ---
        function performCalculation() {
            const outputElement = document.getElementById('output_result');
            const model = document.getElementById('model_select').value;
            outputElement.textContent = `Iniciando cálculo para ${model}...`;

            try {
                if (model === 'bayesian') {
                    outputElement.textContent = calculateBayesianEnumeration();
                    return;
                }
                
                const N_input = document.getElementById('matrix_size').value;
                if (!N_input || isNaN(parseInt(N_input))) {
                     outputElement.textContent = "ERROR: El tamaño de estados (N) no está definido. Presione 'Generar Campos de Matriz'.";
                     return;
                }
                const N = parseInt(N_input);
                
                // Asegurar que los inputs existen (previene error si no presionó 'Generar')
                if (!document.getElementById(`A_${N-1}_${N-1}`)) {
                     outputElement.textContent = "ERROR: Por favor, presione 'Generar Campos de Matriz' antes de calcular.";
                     return;
                }

                const A = readMatrixFromHtml('A', N, N);

                if (model === 'markov') {
                    outputElement.textContent = calculateMarkov(A, N);
                    drawMarkovGraph();
                    return;
                } 
                
                if (model === 'hmm') {
                    const M = parseInt(document.getElementById('observation_size').value);
                    const B = readMatrixFromHtml('B', N, M);
                    const Pi = readVectorFromHtml('Pi', N);
                    
                    const obsStr = document.getElementById('observations').value;
                    let invalidSymptomFound = false;
                    const Observations = obsStr.split(',')
                                            .map(s => s.trim())
                                            .filter(s => s.length > 0)
                                            .map(s => {
                                                const index = SYMPTOM_MAP[s.toLowerCase()];
                                                if (index === undefined || index >= M) {
                                                    invalidSymptomFound = true;
                                                    return -1; 
                                                }
                                                return index;
                                            });

                    if (invalidSymptomFound) {
                        outputElement.textContent = `ERROR: Síntoma no válido o fuera del rango de la Matriz B (0 a ${M - 1}). Válidos: ${SYMPTOM_LABELS.slice(0, M).join(', ')}`;
                        return;
                    }
                    if (Observations.length === 0) {
                         outputElement.textContent = "ERROR: La secuencia de síntomas está vacía.";
                         return;
                    }

                    const validationError = validateStochasticMatrix(A) || validateStochasticMatrix(B);
                    if (validationError) {
                         outputElement.textContent = `ERROR DE VALIDACIÓN: ${validationError}`;
                         return;
                    }

                    // Ejecutar todos los algoritmos HMM
                    const viterbiResult = calculateViterbi(A, B, Pi, Observations); 
                    const { alpha, P_O } = calculateForward(A, B, Pi, Observations);
                    const beta = calculateBackward(A, B, Observations);
                    const gamma = calculateForwardBackward(alpha, beta, P_O);

                    let output = `--- CÁLCULOS HMM ---\n`;
                    output += `Algoritmo Forward (Probabilidad de Observación P(O)): ${P_O.toFixed(6)}\n\n`;
                    output += viterbiResult + '\n\n';
                    output += `Suavizado (Forward-Backward - P(Q_t=i | O)):\n`;
                    
                    for (let t = 0; t < Observations.length; t++) {
                        output += `t=${t}, Obs: ${SYMPTOM_LABELS[Observations[t]] || 'Obs' + Observations[t]}: [${gamma[t].map(p => p.toFixed(4)).join(', ')}]\n`;
                    }

                    outputElement.textContent = output;
                    drawMarkovGraph(); 
                } 
                
                else {
                     outputElement.textContent = "Modelo no implementado o no reconocido.";
                }

            } catch (e) {
                console.error("Error fatal en el cálculo:", e);
                outputElement.textContent = `ERROR FATAL: Ocurrió un error inesperado. Detalle: ${e.message}. (Verifique la consola del navegador para más detalles.)`;
            }
        }
        
        // --- Inicialización ---
        document.addEventListener('DOMContentLoaded', () => {
             toggleInputs();
        });
    </script>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>