<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análisis Avanzado de Modelos - HTML/JavaScript</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/mathjs@12.4.2/lib/browser/math.js"></script>

    <style>
        .matrix-input-container {
            display: grid;
            gap: 5px;
            margin-top: 15px;
        }
        .matrix-input-container input {
            text-align: center;
        }
        #matrix-setup-container, #viterbi-inputs {
            display: none;
        }
    </style>
</head>
<body>

    <div class="container my-5">
        <h1 class="mb-4 text-center text-primary">⚙️ Calculadora Avanzada de Modelos (JavaScript)</h1>
        <p class="text-center text-muted">Funcionamiento garantizado al abrir con doble clic.</p>
        
        <div class="card shadow-sm">
            <div class="card-body">
                
                <div class="mb-4">
                    <label for="model_select" class="form-label h5">1. Seleccionar Modelo de Cálculo:</label>
                    <select id="model_select" class="form-select form-select-lg" onchange="toggleInputs()">
                        <option value="" selected disabled>--- Selecciona un Modelo ---</option>
                        <option value="markov">Cadenas de Markov (Matrices de Transición)</option>
                        <option value="viterbi">Viterbi (Modelo Oculto de Markov - HMM)</option>
                    </select>
                </div>
                
                <div id="matrix-setup-container">
                    <hr>
                    <div class="row g-3 align-items-end mb-4">
                        <div class="col-md-6">
                            <label for="matrix_size" class="form-label h5">2. Tamaño de la Matriz de Transición (N x N):</label>
                            <input type="number" id="matrix_size" class="form-control" value="3" min="2" max="5" oninput="generateMatrixInputs(this.value)">
                        </div>
                        <div class="col-md-6">
                            <button class="btn btn-warning w-100" onclick="generateMatrixInputs(document.getElementById('matrix_size').value)">Generar Campos de Matriz</button>
                        </div>
                    </div>
                    
                    <h5 class="mt-3">Matriz de Transición (A)</h5>
                    <div id="matrix_a_inputs" class="matrix-input-container"></div>

                    <div id="viterbi-inputs">
                        <hr>
                        <h5 class="mt-4">Inputs Adicionales (Modelo Viterbi / HMM)</h5>
                        
                        <div class="mb-3">
                            <label for="observation_size" class="form-label">Tamaño de la Matriz de Emisión (N x M):</label>
                            <input type="number" id="observation_size" class="form-control" value="2" min="1" max="5" oninput="generateEmissionMatrixInputs()">
                        </div>
                        
                        <h5 class="mt-3">Matriz de Emisión (B)</h5>
                        <div id="matrix_b_inputs" class="matrix-input-container"></div>

                        <h5 class="mt-3">Probabilidades Iniciales ($\pi$)</h5>
                        <div id="vector_pi_inputs" class="matrix-input-container"></div>
                        
                        <h5 class="mt-3">Secuencia de Observaciones (Ej: 0, 1, 0)</h5>
                        <input type="text" id="observations" class="form-control" placeholder="Ingrese una secuencia de índices de observación separados por coma (ej: 0,1,0)" value="0,1,0">
                    </div>

                    <hr>
                    <button id="calculate_btn" class="btn btn-success btn-lg w-100 mt-4" onclick="performCalculation()">
                        3. Ejecutar Cálculo
                    </button>
                </div>
            </div>
        </div>

        <div class="card mt-4 shadow-sm">
            <div class="card-header bg-dark text-white h4">
                Resultados
            </div>
            <div class="card-body">
                <pre id="output_result" class="p-3 bg-light border rounded">Seleccione un modelo y presione 'Ejecutar Cálculo'...</pre>
            </div>
        </div>

    </div>

    <script>
        // Alias para la librería mathjs
        const m = math;
        
        // --- Funciones de Interfaz (Las mismas que antes) ---

        function toggleInputs() {
            const model = document.getElementById('model_select').value;
            const setupContainer = document.getElementById('matrix-setup-container');
            const viterbiInputs = document.getElementById('viterbi-inputs');

            if (model) {
                setupContainer.style.display = 'block';
                generateMatrixInputs(document.getElementById('matrix_size').value);
            } else {
                setupContainer.style.display = 'none';
            }

            if (model === 'viterbi') {
                viterbiInputs.style.display = 'block';
                generateEmissionMatrixInputs();
            } else {
                viterbiInputs.style.display = 'none';
            }
        }

        function generateMatrixInputs(N) {
            N = parseInt(N);
            if (isNaN(N) || N < 2) return;
            const A_container = document.getElementById('matrix_a_inputs');
            A_container.innerHTML = '';
            A_container.style.gridTemplateColumns = `repeat(${N}, 1fr)`;
            
            const diagonal_val = 0.7;
            const off_diagonal_val = ((1 - diagonal_val) / (N - 1)).toFixed(3);

            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    const default_val = (i === j) ? diagonal_val : off_diagonal_val;
                    A_container.innerHTML += `<input type="number" step="0.01" min="0" max="1" id="A_${i}_${j}" class="form-control form-control-sm" placeholder="A[${i}][${j}]" value="${default_val}">`;
                }
            }
            if (document.getElementById('model_select').value === 'viterbi') {
                 generateEmissionMatrixInputs();
            }
        }

        function generateEmissionMatrixInputs() {
            const N = parseInt(document.getElementById('matrix_size').value);
            const M = parseInt(document.getElementById('observation_size').value);
            if (isNaN(N) || N < 1 || isNaN(M) || M < 1) return;

            // Matriz B (Emisión)
            const B_container = document.getElementById('matrix_b_inputs');
            B_container.innerHTML = '';
            B_container.style.gridTemplateColumns = `repeat(${M}, 1fr)`;
            const emission_default_val = (1/M).toFixed(3);
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < M; j++) {
                    B_container.innerHTML += `<input type="number" step="0.01" min="0" max="1" id="B_${i}_${j}" class="form-control form-control-sm" placeholder="B[${i}][${j}]" value="${emission_default_val}">`;
                }
            }
            
            // Vector Pi (Inicial)
            const Pi_container = document.getElementById('vector_pi_inputs');
            Pi_container.innerHTML = '';
            Pi_container.style.gridTemplateColumns = `repeat(${N}, 1fr)`;
            const pi_default_val = (1/N).toFixed(3);
            for (let i = 0; i < N; i++) {
                Pi_container.innerHTML += `<input type="number" step="0.01" min="0" max="1" id="Pi_${i}" class="form-control form-control-sm" placeholder="π[${i}]" value="${pi_default_val}">`;
            }
        }
        
        // --- Funciones de Lectura de Datos ---
        
        function readMatrixFromHtml(prefix, N_rows, N_cols) {
            const matrix = [];
            for (let i = 0; i < N_rows; i++) {
                const row = [];
                for (let j = 0; j < N_cols; j++) {
                    const value = document.getElementById(`${prefix}_${i}_${j}`).value;
                    // Usa parseFloat() o 0.0 si está vacío
                    row.push(parseFloat(value) || 0.0); 
                }
                matrix.push(row);
            }
            // Retorna como matriz de math.js
            return m.matrix(matrix); 
        }

        function readVectorFromHtml(prefix, N) {
            const vector = [];
            for (let i = 0; i < N; i++) {
                const value = document.getElementById(`${prefix}_${i}`).value;
                vector.push(parseFloat(value) || 0.0);
            }
            return m.matrix(vector);
        }
        
        // --- Lógica de Modelos (Traducción de Python a JavaScript/math.js) ---

        // Función auxiliar para verificar si las sumas de las filas son 1.0
        function validateStochasticMatrix(matrix, atol = 0.001) {
            const rows = matrix.toArray();
            for (let i = 0; i < rows.length; i++) {
                const sum = rows[i].reduce((a, b) => a + b, 0);
                if (Math.abs(sum - 1.0) > atol) {
                    return `La suma de la fila ${i} es ${sum.toFixed(4)}, debería ser 1.0.`;
                }
            }
            return null;
        }
        
        // Lógica de Cadenas de Markov
        function calculateMarkov(A, N) {
            const validationError = validateStochasticMatrix(A);
            if (validationError) {
                return `ERROR de Validación (Matriz A): ${validationError}`;
            }

            // Encontrar Distribución Estacionaria (pi * A = pi, sum(pi) = 1)
            // Esto se resuelve con un sistema lineal: (A^T - I) * pi = 0
            // Math.js maneja bien estas operaciones
            
            try {
                // 1. Crear A^T - I
                const I = m.identity(N);
                const At = m.transpose(A);
                const M = m.subtract(At, I);
                
                // 2. Reemplazar la última fila por [1, 1, ..., 1] para la condición sum(pi) = 1
                const M_array = M.toArray();
                M_array[N - 1] = Array(N).fill(1.0);
                const M_solved = m.matrix(M_array);
                
                // 3. Crear el vector b = [0, 0, ..., 1]
                const b = Array(N).fill(0.0);
                b[N - 1] = 1.0;

                // 4. Resolver M * pi = b para pi
                const pi_stationary_matrix = m.lusolve(M_solved, b);
                const pi_stationary = m.squeeze(pi_stationary_matrix).toArray(); // Convierte a vector

                const output = `--- CÁLCULO DE CADENA DE MARKOV ---\n`
                    + `Matriz de Transición (A):\n${m.format(A, {precision: 4})}\n\n`
                    + `Distribución Estacionaria (π):\n${m.format(pi_stationary, {precision: 4})}\n`
                    + `Esta distribución representa la probabilidad a largo plazo de estar en cada estado.`;
                return output;

            } catch (e) {
                return `ERROR de Cálculo: No se pudo encontrar la distribución estacionaria. La matriz podría ser periódica o no regular. Detalle: ${e.message}`;
            }
        }

        // Lógica del Algoritmo de Viterbi
        function calculateViterbi(A, B, Pi, Observations) {
            // Validación de sumas
            const validationA = validateStochasticMatrix(A);
            if (validationA) return `ERROR de Validación (Matriz A): ${validationA}`;
            const validationB = validateStochasticMatrix(B);
            if (validationB) return `ERROR de Validación (Matriz B): ${validationB}`;
            
            const sumPi = Pi.toArray().reduce((a, b) => a + b, 0);
            if (Math.abs(sumPi - 1.0) > 0.001) {
                return `ERROR de Validación (Vector Pi): La suma de las probabilidades iniciales es ${sumPi.toFixed(4)}, debería ser 1.0.`;
            }

            const N = A.size()[0]; // Número de estados
            const T = Observations.length; // Longitud de la secuencia

            if (T === 0) {
                return "ERROR: La secuencia de observaciones está vacía.";
            }

            // Inicialización (usando logaritmos para evitar underflow)
            const delta = m.zeros(T, N);
            const psi = m.zeros(T, N);
            
            const A_arr = A.toArray();
            const B_arr = B.toArray();
            const Pi_arr = Pi.toArray();
            const delta_arr = delta.toArray();
            const psi_arr = psi.toArray();

            // Paso de Inicialización (t=0)
            for (let i = 0; i < N; i++) {
                const log_pi = Pi_arr[i] > 0 ? Math.log(Pi_arr[i]) : -Infinity;
                const log_b = B_arr[i][Observations[0]] > 0 ? Math.log(B_arr[i][Observations[0]]) : -Infinity;
                delta_arr[0][i] = log_pi + log_b;
            }

            // Paso de Recurrencia (t=1 a T-1)
            for (let t = 1; t < T; t++) {
                const o_t = Observations[t];
                for (let j = 0; j < N; j++) {
                    let log_max_prob = -Infinity;
                    let max_state = 0;
                    
                    for (let i = 0; i < N; i++) {
                        const log_a = A_arr[i][j] > 0 ? Math.log(A_arr[i][j]) : -Infinity;
                        const prob = delta_arr[t-1][i] + log_a;
                        
                        if (prob > log_max_prob) {
                            log_max_prob = prob;
                            max_state = i;
                        }
                    }
                    
                    const log_b = B_arr[j][o_t] > 0 ? Math.log(B_arr[j][o_t]) : -Infinity;
                    delta_arr[t][j] = log_max_prob + log_b;
                    psi_arr[t][j] = max_state;
                }
            }
            
            // Paso de Terminación
            let log_P_star = -Infinity;
            let Q_T_minus_1 = 0;
            for (let i = 0; i < N; i++) {
                if (delta_arr[T-1][i] > log_P_star) {
                    log_P_star = delta_arr[T-1][i];
                    Q_T_minus_1 = i;
                }
            }
            
            const Q_star = new Array(T);
            Q_star[T-1] = Q_T_minus_1;

            // Paso de Retroceso
            for (let t = T - 2; t >= 0; t--) {
                Q_star[t] = psi_arr[t + 1][Q_star[t + 1]];
            }

            const output = `--- CÁLCULO DE VITERBI (HMM) ---\n`
                + `Secuencia de Observaciones: [${Observations.join(', ')}]\n\n`
                + `Matriz de Transición (A):\n${m.format(A, {precision: 4})}\n\n`
                + `Matriz de Emisión (B):\n${m.format(B, {precision: 4})}\n\n`
                + `Probabilidades Iniciales (π):\n${m.format(Pi, {precision: 4})}\n\n`
                + `Secuencia de Estados Ocultos Más Probable (Q*):\n[${Q_star.join(', ')}]\n`
                + `Probabilidad Logarítmica (Máxima) de la Secuencia Q*: ${log_P_star.toFixed(4)}`;
            
            return output;
        }


        // --- FUNCIÓN PRINCIPAL DE CÁLCULO (Vinculada al botón) ---
        function performCalculation() {
            const outputElement = document.getElementById('output_result');
            outputElement.textContent = "Iniciando cálculo...";

            const model = document.getElementById('model_select').value;
            
            if (!model) {
                outputElement.textContent = "ERROR: Por favor, seleccione un modelo de cálculo.";
                return;
            }

            try {
                const N = parseInt(document.getElementById('matrix_size').value);
                
                // 1. Leer Matriz de Transición (A)
                const A = readMatrixFromHtml('A', N, N);

                let result;
                
                if (model === 'markov') {
                    result = calculateMarkov(A, N);
                } 
                
                else if (model === 'viterbi') {
                    const M = parseInt(document.getElementById('observation_size').value);
                    
                    // 2. Leer Matriz de Emisión (B)
                    const B = readMatrixFromHtml('B', N, M);
                    
                    // 3. Leer Vector Inicial (Pi)
                    const Pi = readVectorFromHtml('Pi', N);
                    
                    // 4. Leer Secuencia de Observaciones
                    const obsStr = document.getElementById('observations').value;
                    const Observations = obsStr.split(',')
                                            .map(s => s.trim())
                                            .filter(s => s.length > 0)
                                            .map(s => parseInt(s));

                    if (Observations.some(isNaN)) {
                        outputElement.textContent = "ERROR: La secuencia de observaciones contiene valores no numéricos. Use solo enteros separados por comas (ej: 0,1,0).";
                        return;
                    }

                    result = calculateViterbi(A, B, Pi, Observations);
                } 
                
                else {
                     result = "Modelo no implementado o no reconocido.";
                }

                outputElement.textContent = result;

            } catch (e) {
                console.error("Error fatal en el cálculo:", e);
                outputElement.textContent = `ERROR FATAL: Ocurrió un error inesperado. Revise que haya generado los campos de la matriz e ingresado todos los datos. Detalle del error: ${e.message}`;
            }
        }
        
        // Inicializar la interfaz (opcional, pero útil)
        document.addEventListener('DOMContentLoaded', () => {
             // Simular la generación inicial de campos para el estado por defecto (Markov)
             toggleInputs();
        });

    </script>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>